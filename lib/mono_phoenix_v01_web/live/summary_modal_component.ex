defmodule MonoPhoenixV01Web.SummaryModalComponent do
  use MonoPhoenixV01Web, :live_component

  @impl true
  def render(assigns) do
    ~H"""
    <div
      id="summary-modal"
      class="summary-modal-overlay"
      style={if @show, do: "display: block;", else: "display: none;"}
      phx-hook="ModalClickHandler"
      phx-target={@myself}
      data-record-id={@record_id}
    >
      <!-- Confirmation Dialog -->
      <div 
        id="confirmation-dialog" 
        class="confirmation-dialog-overlay" 
        style={if @show_confirmation, do: "display: flex;", else: "display: none;"}
      >
        <div class="confirmation-dialog">
          <div class="confirmation-dialog-header">
            <h4 id="confirmation-dialog-title">Cancel Generation?</h4>
          </div>
          <div class="confirmation-dialog-body">
            <p id="confirmation-dialog-message">Claude is still generating content. Are you sure you want to cancel and close this window?</p>
          </div>
          <div class="confirmation-dialog-buttons">
            <button 
              class="confirmation-btn confirm-cancel"
              phx-click="close_modal"
              phx-value-force="true"
              phx-target={@myself}
            >
              Yes, cancel
            </button>
            <button 
              class="confirmation-btn confirm-wait"
              phx-click="hide_confirmation"
              phx-target={@myself}
            >
              No, wait
            </button>
          </div>
        </div>
      </div>

      <div class="summary-modal-content">
        <div class="summary-modal-header">
          <h3 class="summary-modal-title"><%= @title %></h3>
          <button 
            class="summary-modal-close" 
            aria-label="Close modal"
          >
            &times;
          </button>
        </div>
        <div class="summary-modal-body">
          <%= if @loading do %>
            <div class="summary-loading">
              <div class="loading-spinner"></div>
              <p>Generating <%= String.downcase(@content_type) %>...</p>
            </div>
          <% else %>
            <%= if @error do %>
              <div class="summary-error">
                <p><strong>Error:</strong> <%= @error %></p>
                <button 
                  class="retry-button" 
                  phx-click="retry_generation"
                  phx-target={@myself}
                >
                  Try Again
                </button>
              </div>
            <% else %>
              <div class="summary-content">
                <%= raw render_markdown(@content) %>
              </div>
              <div class="summary-modal-footer">
                <div class="ai-disclaimer">
                  <em>Note: This content was generated by AI (Claude). It may contain errors.</em>
                </div>
                <button 
                  class="copy-to-clipboard-btn" 
                  phx-click="copy_to_clipboard"
                  phx-target={@myself}
                  title="Copy to clipboard"
                >
                  ðŸ“‹
                </button>
              </div>
            <% end %>
          <% end %>
        </div>
      </div>
    </div>
    """
  end

  @impl true
  def mount(socket) do
    {:ok, assign(socket, 
      show: false, 
      loading: false, 
      content: "", 
      title: "", 
      content_type: "",
      error: nil,
      generation_params: %{},
      canceled: false,
      show_confirmation: false,
      record_id: nil
    )}
  end

  @impl true
  def handle_event("modal_close_request", _params, socket) do
    if socket.assigns.loading do
      # Show confirmation dialog
      {:noreply, assign(socket, show_confirmation: true)}
    else
      # Not loading - close normally  
      {:noreply, assign(socket, show: false)}
    end
  end

  @impl true
  def handle_event("close_modal", params, socket) do
    case params do
      %{"force" => "true"} ->
        # Force close - user confirmed they want to cancel
        require Logger
        Logger.info("User confirmed cancellation - stopping generation")
        
        # Notify parent LiveView that user canceled generation
        send(self(), {:cancel_generation, "summary-modal"})
        
        {:noreply, assign(socket, show: false, loading: false, error: nil, canceled: true, show_confirmation: false)}
      
      _ ->
        # Fallback handler
        {:noreply, assign(socket, show: false)}
    end
  end

  @impl true
  def handle_event("hide_confirmation", _params, socket) do
    {:noreply, assign(socket, show_confirmation: false)}
  end

  @impl true
  def handle_event("copy_to_clipboard", _, socket) do
    # The actual copying will be handled by JavaScript
    {:noreply, socket}
  end

  @impl true
  def handle_event("retry_generation", _, socket) do
    params = socket.assigns.generation_params
    content_type = socket.assigns.content_type
    
    socket = assign(socket, loading: true, error: nil)
    
    # Map content type to the message type expected by LiveView
    message_type = case content_type do
      "Play Summary" -> "play_summary"
      "Scene Summary" -> "scene_summary" 
      "Paraphrasing" -> "paraphrasing"
      _ -> String.downcase(content_type)
    end
    
    # Use PubSub to communicate with parent LiveView
    Phoenix.PubSub.broadcast(
      MonoPhoenixV01.PubSub,
      "play_page_events",
      {:generate_summary, message_type, params, "summary-modal"}
    )
    
    {:noreply, socket}
  end

  @impl true
  def update(%{action: "show_play_summary", play_title: play_title}, socket) do
    socket = assign(socket,
      show: true,
      loading: true, 
      title: "Play Summary: #{play_title}",
      content_type: "Play Summary",
      error: nil,
      generation_params: %{play_title: play_title},
      canceled: false
    )
    
    {:ok, socket}
  end

  @impl true
  def update(%{action: "show_scene_summary", play_title: play_title, location: location}, socket) do
    socket = assign(socket,
      show: true,
      loading: true,
      title: "Scene Summary: #{play_title} - #{location}", 
      content_type: "Scene Summary",
      error: nil,
      generation_params: %{play_title: play_title, location: location},
      canceled: false
    )
    
    {:ok, socket}
  end

  @impl true
  def update(%{action: "show_paraphrasing", monologue_id: monologue_id, monologue_text: monologue_text, character: character}, socket) do
    socket = assign(socket,
      show: true,
      loading: true,
      title: "Modern Paraphrasing: #{character}",
      content_type: "Paraphrasing", 
      error: nil,
      generation_params: %{monologue_id: monologue_id, monologue_text: monologue_text},
      canceled: false
    )
    
    {:ok, socket}
  end

  @impl true
  def update(%{action: "content_generated", content: content, record_id: record_id}, socket) do
    if socket.assigns.canceled do
      {:ok, socket}
    else
      {:ok, assign(socket, loading: false, content: content, record_id: record_id)}
    end
  end

  @impl true
  def update(%{action: "content_generated", content: content}, socket) do
    # Fallback for updates without record_id (shouldn't happen with new code)
    if socket.assigns.canceled do
      {:ok, socket}
    else
      {:ok, assign(socket, loading: false, content: content)}
    end
  end

  @impl true
  def update(%{action: "content_error", error: error}, socket) do
    if socket.assigns.canceled do
      {:ok, socket}
    else
      {:ok, assign(socket, loading: false, error: error)}
    end
  end


  @impl true
  def update(assigns, socket) do
    {:ok, assign(socket, assigns)}
  end

  # Private helper functions

  defp render_markdown(content) do
    case Earmark.as_html(content) do
      {:ok, html, _messages} -> 
        # Post-process to fix paraphrasing formatting
        html
        |> String.replace(~r/Original:/i, "<strong>Original:</strong>")
        |> String.replace(~r/Modern:/i, "<br><strong>Modern:</strong>")
      {:error, html, _error_messages} -> html  # Even on error, Earmark provides partial HTML
      _ -> content  # Fallback to raw content for any unexpected return format
    end
  end

end