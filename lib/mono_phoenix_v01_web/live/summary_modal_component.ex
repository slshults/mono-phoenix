defmodule MonoPhoenixV01Web.SummaryModalComponent do
  use MonoPhoenixV01Web, :live_component

  @impl true
  def render(assigns) do
    ~H"""
    <div
      id="summary-modal"
      class="summary-modal-overlay"
      style={if @show, do: "display: block;", else: "display: none;"}
      phx-hook="ModalClickHandler"
      phx-target={@myself}
      data-record-id={@record_id}
      data-loading={@loading}
    >
      <!-- Confirmation Dialog -->
      <div 
        id="confirmation-dialog" 
        class="confirmation-dialog-overlay" 
        style={if @show_confirmation, do: "display: flex;", else: "display: none;"}
      >
        <div class="confirmation-dialog">
          <div class="confirmation-dialog-header">
            <h4 id="confirmation-dialog-title">Cancel Generation?</h4>
          </div>
          <div class="confirmation-dialog-body">
            <p id="confirmation-dialog-message">Claude is still generating content. Are you sure you want to cancel and close this window?</p>
          </div>
          <div class="confirmation-dialog-buttons">
            <button 
              class="confirmation-btn confirm-cancel"
              phx-click="close_modal"
              phx-value-force="true"
              phx-target={@myself}
            >
              Yes, cancel
            </button>
            <button 
              class="confirmation-btn confirm-wait"
              phx-click="hide_confirmation"
              phx-target={@myself}
            >
              No, wait
            </button>
          </div>
        </div>
      </div>

      <div class="summary-modal-content">
        <div class="summary-modal-header">
          <h3 class="summary-modal-title"><%= @title %></h3>
          <button 
            class="summary-modal-close" 
            aria-label="Close modal"
          >
            &times;
          </button>
        </div>
        <div class="summary-modal-body">
          <%= if @loading do %>
            <div class="summary-loading">
              <div class="loading-spinner"></div>
              <p>Generating <%= String.downcase(@content_type) %>...</p>
            </div>
          <% else %>
            <%= if @error do %>
              <div class="summary-error">
                <p><strong>Error:</strong> <%= @error %></p>
                <button 
                  class="retry-button" 
                  phx-click="retry_generation"
                  phx-target={@myself}
                >
                  Try Again
                </button>
              </div>
            <% else %>
              <div class="summary-content">
                <%= raw render_markdown(@content) %>
              </div>
              <div class="summary-modal-footer">
                <div class="footer-top-row">
                  <div class="footer-left-section">
                    <div class="ai-disclaimer">
                      <em>Note: This content was generated by AI (Claude). It may contain errors.</em>
                    </div>
                    <div class="feedback-section">
                      <%= if @feedback_success do %>
                        <div class="feedback-thanks">Thanks!</div>
                      <% else %>
                        <%# Show thumbs only if feedback not yet completed %>
                        <%= unless @feedback_completed do %>
                          <div class="feedback-buttons">
                            <button 
                              class="feedback-btn feedback-thumbs-btn" 
                              phx-click="toggle_feedback"
                              phx-target={@myself}
                              title="Give feedback on this content"
                            >
                              <svg class="thumb-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"/>
                              </svg>
                              <svg class="thumb-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"/>
                              </svg>
                            </button>
                          </div>
                        <% end %>
                      <% end %>
                    </div>
                  </div>
                  <button 
                    class="copy-to-clipboard-btn" 
                    phx-click="copy_to_clipboard"
                    phx-target={@myself}
                    title="Copy to clipboard"
                  >
                    ðŸ“‹
                  </button>
                </div>
              </div>

              <!-- Feedback Overlay -->
              <div 
                id="feedback-overlay"
                class="feedback-overlay" 
                style={if @show_feedback, do: "display: block;", else: "display: none;"}
                phx-hook="FeedbackForm"
              >
                <div class="feedback-form">
                  <%= unless @feedback_success do %>
                    <h4>What's wrong with this <%= String.downcase(@content_type) %>?</h4>
                    <form phx-submit="submit_feedback" phx-target={@myself}>
                      <div class="feedback-checkboxes">
                        <label>
                          <input type="checkbox" name="feedback[]" value="dont_understand" />
                          I don't understand it
                        </label>
                        <label>
                          <input type="checkbox" name="feedback[]" value="dont_like" />
                          I don't like it
                        </label>
                        <label>
                          <input type="checkbox" name="feedback[]" value="wrong" />
                          It's wrong
                        </label>
                        <label>
                          <input type="checkbox" name="feedback[]" value="like_it" />
                          I like it
                        </label>
                        <label>
                          <input type="checkbox" name="feedback[]" value="button_pusher" />
                          I just like to push buttons to see what they do
                        </label>
                        <label>
                          <input type="checkbox" name="feedback[]" value="why_talking" />
                          Why is it talking to me?
                        </label>
                      </div>
                      <div class="feedback-wrong-details" style={if @show_wrong_details, do: "display: block;", else: "display: none;"}>
                        <textarea 
                          name="wrong_details" 
                          placeholder="What's wrong? (optional)"
                          rows="2"
                        ></textarea>
                      </div>
                      <div class="feedback-form-buttons">
                        <button 
                          type="submit" 
                          class="feedback-send-btn"
                          disabled={@sending_feedback}
                        >
                          <%= if @sending_feedback do %>
                            Sending...
                          <% else %>
                            Send
                          <% end %>
                        </button>
                        <button type="button" class="feedback-cancel-btn" phx-click="toggle_feedback" phx-target={@myself}>Cancel</button>
                      </div>
                    </form>
                  <% end %>
                </div>
              </div>
            <% end %>
          <% end %>
        </div>
      </div>
      
      <!-- Component styles -->
      <style>
        .summary-modal-footer {
          margin-top: 15px;
        }
        
        .footer-top-row {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
          width: 100%;
        }
        
        .footer-left-section {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 4px;
          flex: 1;
        }
        
        .copy-to-clipboard-btn {
          align-self: flex-end;
        }
        
        .feedback-section {
          position: relative;
        }
        
        .feedback-buttons {
          display: flex;
          gap: 8px;
        }
        
        .feedback-btn {
          background: none;
          border: none;
          cursor: pointer;
          padding: 4px;
          border-radius: 3px;
          display: flex;
          align-items: center;
          opacity: 0.7;
          transition: opacity 0.2s;
        }
        
        .feedback-btn:hover {
          opacity: 1;
          background-color: rgba(0,0,0,0.05);
        }
        
        .feedback-thumbs-btn {
          display: flex;
          gap: 4px;
        }
        
        .thumb-icon {
          width: 14px;
          height: 14px;
        }
        
        .feedback-thanks {
          font-size: 12px;
          color: #2d5016;
          font-weight: normal;
          padding: 2px 0;
        }
        
        .feedback-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 300px;
          max-width: 90vw;
          background-color: rgba(240,240,200,0.98);
          z-index: 1000;
          border-radius: 8px;
          border: 1px solid #ddd;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .feedback-form {
          padding: 16px;
        }
        
        .feedback-form h4 {
          margin: 0 0 12px 0;
          color: #333;
          font-size: 14px;
          font-weight: 600;
        }
        
        .feedback-checkboxes {
          display: flex;
          flex-direction: column;
          gap: 6px;
          margin-bottom: 12px;
        }
        
        .feedback-checkboxes label {
          display: flex;
          align-items: center;
          gap: 6px;
          cursor: pointer;
          font-size: 13px;
          color: #555;
        }
        
        .feedback-checkboxes input[type="checkbox"] {
          margin: 0;
          width: 14px;
          height: 14px;
        }
        
        .feedback-wrong-details {
          margin-bottom: 12px;
        }
        
        .feedback-wrong-details textarea {
          width: 100%;
          padding: 6px;
          border: 1px solid #ccc;
          border-radius: 4px;
          font-family: inherit;
          font-size: 12px;
          resize: vertical;
          box-sizing: border-box;
        }
        
        .feedback-form-buttons {
          display: flex;
          gap: 8px;
          justify-content: flex-end;
        }
        
        .feedback-send-btn {
          padding: 8px 16px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 500;
          background-color: #555;
          color: #F9F9DF;
          transition: all 0.2s ease;
          font-family: 'IM Fell DW Pica', serif;
        }
        
        .feedback-send-btn:hover:not(:disabled) {
          background-color: #333;
          transform: translateY(-1px);
        }
        
        .feedback-send-btn:disabled {
          opacity: 0.6;
          cursor: not-allowed;
          transform: none;
        }
        
        .feedback-cancel-btn {
          padding: 8px 16px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 500;
          background-color: #888;
          color: white;
          transition: all 0.2s ease;
          font-family: 'IM Fell DW Pica', serif;
        }
        
        .feedback-cancel-btn:hover {
          background-color: #666;
          transform: translateY(-1px);
        }
        
        /* Dark mode compatibility */
        body.dark-mode .feedback-overlay {
          background-color: rgba(40,40,40,0.98);
          border-color: #555;
        }
        
        body.dark-mode .feedback-form h4 {
          color: #fff;
        }
        
        body.dark-mode .feedback-checkboxes label {
          color: #ccc;
        }
        
        body.dark-mode .feedback-wrong-details textarea {
          background-color: #333;
          color: #fff;
          border-color: #666;
        }
        
        body.dark-mode .feedback-thanks {
          color: #90EE90;
        }
        
        body.dark-mode .feedback-btn:hover {
          background-color: rgba(255,255,255,0.05);
        }
        
        body.dark-mode .feedback-send-btn {
          background-color: #F9F9DF;
          color: #333;
        }
        
        body.dark-mode .feedback-send-btn:hover:not(:disabled) {
          background-color: #F0F0D0;
          color: #333;
        }
        
        body.dark-mode .feedback-send-btn:disabled {
          opacity: 0.6;
          cursor: not-allowed;
        }
      </style>
    </div>
    """
  end

  @impl true
  def mount(socket) do
    {:ok, assign(socket, 
      show: false, 
      loading: false, 
      content: "", 
      title: "", 
      content_type: "",
      error: nil,
      generation_params: %{},
      canceled: false,
      show_confirmation: false,
      record_id: nil,
      show_feedback: false,
      feedback_success: false,
      feedback_completed: false,
      sending_feedback: false,
      show_wrong_details: false
    )}
  end

  @impl true
  def handle_event("modal_close_request", _params, socket) do
    if socket.assigns.loading do
      # Show confirmation dialog
      {:noreply, assign(socket, show_confirmation: true)}
    else
      # Not loading - close normally  
      {:noreply, assign(socket, show: false)}
    end
  end

  @impl true
  def handle_event("close_modal", params, socket) do
    case params do
      %{"force" => "true"} ->
        # Force close - user confirmed they want to cancel
        require Logger
        Logger.info("User confirmed cancellation - stopping generation")
        
        # Notify parent LiveView that user canceled generation
        send(self(), {:cancel_generation, "summary-modal"})
        
        {:noreply, assign(socket, show: false, loading: false, error: nil, canceled: true, show_confirmation: false)}
      
      _ ->
        # Fallback handler
        {:noreply, assign(socket, show: false)}
    end
  end

  @impl true
  def handle_event("hide_confirmation", _params, socket) do
    {:noreply, assign(socket, show_confirmation: false)}
  end

  @impl true
  def handle_event("copy_to_clipboard", _, socket) do
    # The actual copying will be handled by JavaScript
    {:noreply, socket}
  end

  @impl true
  def handle_event("retry_generation", _, socket) do
    params = socket.assigns.generation_params
    content_type = socket.assigns.content_type
    
    socket = assign(socket, loading: true, error: nil)
    
    # Map content type to the message type expected by LiveView
    message_type = case content_type do
      "Play Summary" -> "play_summary"
      "Scene Summary" -> "scene_summary" 
      "Paraphrasing" -> "paraphrasing"
      _ -> String.downcase(content_type)
    end
    
    # Use PubSub to communicate with parent LiveView
    Phoenix.PubSub.broadcast(
      MonoPhoenixV01.PubSub,
      "play_page_events",
      {:generate_summary, message_type, params, "summary-modal"}
    )
    
    {:noreply, socket}
  end

  @impl true
  def handle_event("toggle_feedback", _params, socket) do
    socket = assign(socket, 
      show_feedback: !socket.assigns.show_feedback,
      feedback_success: false,
      show_wrong_details: false
    )
    {:noreply, socket}
  end

  @impl true
  def handle_event("reset_feedback_success", _params, socket) do
    require Logger
    Logger.info("Resetting feedback success - before: feedback_success=#{socket.assigns.feedback_success}, feedback_completed=#{socket.assigns.feedback_completed}")
    
    # Only reset the "Thanks!" message, but explicitly keep feedback_completed true
    # so the thumbs buttons don't reappear
    socket = assign(socket, 
      feedback_success: false,
      feedback_completed: socket.assigns.feedback_completed
    )
    
    Logger.info("After reset: feedback_success=#{socket.assigns.feedback_success}, feedback_completed=#{socket.assigns.feedback_completed}")
    {:noreply, socket}
  end

  @impl true
  def handle_event("submit_feedback", params, socket) do
    feedback_items = Map.get(params, "feedback", [])
    wrong_details = Map.get(params, "wrong_details", "")
    
    # Show wrong details field if "wrong" is checked
    socket = if "wrong" in feedback_items do
      assign(socket, show_wrong_details: true, sending_feedback: true)
    else
      assign(socket, sending_feedback: true)
    end
    
    # Process the feedback
    case send_feedback_email(socket.assigns, feedback_items, wrong_details) do
      {:ok, _result} ->
        # PostHog event will be tracked by JavaScript when success is shown
        
        {:noreply, assign(socket, feedback_success: true, feedback_completed: true, show_feedback: false, sending_feedback: false)}
      
      {:error, reason} ->
        require Logger
        Logger.error("Failed to send feedback email: #{inspect(reason)}")
        {:noreply, assign(socket, sending_feedback: false)}
    end
  end

  @impl true
  def update(%{action: "show_play_summary", play_title: play_title}, socket) do
    socket = assign(socket,
      show: true,
      loading: true, 
      title: "Play Summary: #{play_title}",
      content_type: "Play Summary",
      error: nil,
      generation_params: %{play_title: play_title},
      canceled: false,
      feedback_success: false,
      feedback_completed: false,
      sending_feedback: false,
      show_feedback: false
    )
    
    {:ok, socket}
  end

  @impl true
  def update(%{action: "show_scene_summary", play_title: play_title, location: location}, socket) do
    socket = assign(socket,
      show: true,
      loading: true,
      title: "Scene Summary: #{play_title} - #{location}", 
      content_type: "Scene Summary",
      error: nil,
      generation_params: %{play_title: play_title, location: location},
      canceled: false,
      feedback_success: false,
      feedback_completed: false,
      sending_feedback: false,
      show_feedback: false
    )
    
    {:ok, socket}
  end

  @impl true
  def update(%{action: "show_paraphrasing", monologue_id: monologue_id, monologue_text: monologue_text, character: character}, socket) do
    socket = assign(socket,
      show: true,
      loading: true,
      title: "Modern Paraphrasing: #{character}",
      content_type: "Paraphrasing", 
      error: nil,
      generation_params: %{monologue_id: monologue_id, monologue_text: monologue_text},
      canceled: false,
      feedback_success: false,
      feedback_completed: false,
      sending_feedback: false,
      show_feedback: false
    )
    
    {:ok, socket}
  end

  @impl true
  def update(%{action: "content_generated", content: content, record_id: record_id}, socket) do
    if socket.assigns.canceled do
      {:ok, socket}
    else
      {:ok, assign(socket, loading: false, content: content, record_id: record_id)}
    end
  end

  @impl true
  def update(%{action: "content_generated", content: content}, socket) do
    # Fallback for updates without record_id (shouldn't happen with new code)
    if socket.assigns.canceled do
      {:ok, socket}
    else
      {:ok, assign(socket, loading: false, content: content)}
    end
  end

  @impl true
  def update(%{action: "content_error", error: error}, socket) do
    if socket.assigns.canceled do
      {:ok, socket}
    else
      {:ok, assign(socket, loading: false, error: error)}
    end
  end


  @impl true
  def update(assigns, socket) do
    {:ok, assign(socket, assigns)}
  end


  # Private helper functions

  defp fetch_monologue_details(monologue_id) do
    import Ecto.Query
    require Logger
    
    Logger.info("Fetching monologue details for ID: #{inspect(monologue_id)} (type: #{inspect(is_integer(monologue_id))})")
    
    try do
      # First, let's see if we can find the record at all
      count_query = from(m in "monologues", where: m.id == ^monologue_id, select: count())
      count_result = MonoPhoenixV01.Repo.one(count_query)
      Logger.info("Found #{count_result} records matching ID #{monologue_id}")
      
      result = MonoPhoenixV01.Repo.one(
        from(m in "monologues",
          where: m.id == ^monologue_id,
          select: %{
            location: m.location,
            character: m.character,
            firstline: m.first_line
          }
        )
      )
      
      Logger.info("Raw query result: #{inspect(result)}")
      
      # Let's also log what fields are nil vs empty string
      if result do
        Logger.info("Field values - location: #{inspect(result.location)}, character: #{inspect(result.character)}, firstline: #{inspect(result.firstline)}")
      end
      
      result || %{}
    rescue
      error ->
        Logger.error("Database error fetching monologue details: #{inspect(error)}")
        # Return empty map if database query fails
        %{}
    end
  end

  defp send_feedback_email(assigns, feedback_items, wrong_details) do
    require Logger
    
    # Build monologue details based on content type
    monologue_details = case assigns.content_type do
      "Play Summary" ->
        play_title = Map.get(assigns.generation_params, :play_title, "Unknown")
        "Play: #{play_title}"
      
      "Scene Summary" ->
        play_title = Map.get(assigns.generation_params, :play_title, "Unknown")
        location = Map.get(assigns.generation_params, :location, "Unknown")
        "Play: #{play_title}, Act/Scene: #{location}"
      
      "Paraphrasing" ->
        monologue_id = Map.get(assigns.generation_params, :monologue_id, "Unknown")
        
        Logger.info("Processing paraphrasing feedback - monologue_id: #{inspect(monologue_id)} (type: #{inspect(is_integer(monologue_id))})")
        Logger.info("Generation params: #{inspect(assigns.generation_params)}")
        
        # Convert to integer if it's a string
        actual_monologue_id = case monologue_id do
          id when is_integer(id) -> id
          id when is_binary(id) ->
            case Integer.parse(id) do
              {parsed_id, ""} -> parsed_id
              _ -> nil
            end
          _ -> nil
        end
        
        Logger.info("Converted monologue_id: #{inspect(actual_monologue_id)}")
        
        # Fetch monologue details from database
        details = if actual_monologue_id && actual_monologue_id != "Unknown" do
          fetch_monologue_details(actual_monologue_id)
        else
          Logger.info("Monologue ID is invalid or 'Unknown', skipping database query")
          %{}
        end
        
        Logger.info("Fetched details: #{inspect(details)}")
        
        location = Map.get(details, :location, "Unknown")
        character = Map.get(details, :character, "Unknown")
        first_line = Map.get(details, :firstline, "Unknown")
        
        Logger.info("Final values - Character: #{character}, Location: #{location}, First Line: #{first_line}")
        
        "Character: #{character}, Location: #{location}, First Line: \"#{first_line}\""
      
      _ -> 
        "Unknown content type"
    end
    
    feedback_text = Enum.join(feedback_items, ", ")
    
    email_body = """
    Feedback received for AI-generated content on Shakespeare Monologues site.

    Content Type: #{assigns.content_type}
    #{monologue_details}

    Feedback Options Selected: #{feedback_text}

    #{if wrong_details != "", do: "Additional Details: #{wrong_details}", else: ""}

    ---
    This feedback was submitted via the shakespeare-monologues.org feedback form.
    """
    
    email_struct = Swoosh.Email.new()
    |> Swoosh.Email.to("shakesmonos@shults.org")
    |> Swoosh.Email.from({"ShakesMonos AI Feedback", "shakesmonos@shults.org"})
    |> Swoosh.Email.subject("AI Content Feedback: #{assigns.content_type}")
    |> Swoosh.Email.text_body(email_body)
    
    MonoPhoenixV01.Mailer.deliver(email_struct)
  end


  defp render_markdown(content) do
    case Earmark.as_html(content) do
      {:ok, html, _messages} -> 
        # Post-process to fix paraphrasing formatting
        html
        |> String.replace(~r/Original:/i, "<strong>Original:</strong>")
        |> String.replace(~r/Modern:/i, "<br><strong>Modern:</strong>")
      {:error, html, _error_messages} -> html  # Even on error, Earmark provides partial HTML
      _ -> content  # Fallback to raw content for any unexpected return format
    end
  end

end