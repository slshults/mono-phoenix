{"version":3,"file":"compression.js","sourceRoot":"","sources":["../../src/compression.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,QAAQ,CAAA;AAC1C,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAA;AACvC,OAAO,EAAE,WAAW,EAA+B,MAAM,SAAS,CAAA;AAElE,MAAM,UAAU,iBAAiB,CAAC,kBAAyD;IACvF,IAAI,kBAAkB,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE;QACxC,OAAO,WAAW,CAAC,MAAM,CAAA;KAC5B;SAAM;QACH,OAAO,WAAW,CAAC,MAAM,CAAA;KAC5B;AACL,CAAC;AAED,MAAM,UAAU,YAAY,CACxB,WAAwB,EACxB,QAAgB,EAChB,OAAmB;IAEnB,IAAI,WAAW,KAAK,WAAW,CAAC,MAAM,EAAE;QACpC,gHAAgH;QAChH,OAAO;YACH,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;kCACpC,OAAO,KAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,EAAE,WAAW,EAAE,WAAW,CAAC,MAAM,EAAE;SAC9E,CAAA;KACJ;SAAM;QACH,OAAO,CAAC,EAAE,IAAI,EAAE,aAAa,CAAC,QAAQ,CAAC,EAAE,EAAE,OAAO,CAAC,CAAA;KACtD;AACL,CAAC","sourcesContent":["import { gzipSync, strToU8 } from 'fflate'\nimport { _base64Encode } from './utils'\nimport { Compression, CompressionData, XHROptions } from './types'\n\nexport function decideCompression(compressionSupport: Partial<Record<Compression, boolean>>): Compression {\n    if (compressionSupport[Compression.GZipJS]) {\n        return Compression.GZipJS\n    } else {\n        return Compression.Base64\n    }\n}\n\nexport function compressData(\n    compression: Compression,\n    jsonData: string,\n    options: XHROptions\n): [CompressionData | Uint8Array, XHROptions] {\n    if (compression === Compression.GZipJS) {\n        // :TRICKY: This returns an UInt8Array. We don't encode this to a string - returning a blob will do this for us.\n        return [\n            gzipSync(strToU8(jsonData), { mtime: 0 }),\n            { ...options, blob: true, urlQueryArgs: { compression: Compression.GZipJS } },\n        ]\n    } else {\n        return [{ data: _base64Encode(jsonData) }, options]\n    }\n}\n"]}