import { _bind_instance_methods, _each, _extend, _includes, _register_event, _safewrap_instance_methods } from './utils';
import { autocaptureCompatibleElements, getClassNames, getDirectAndNestedSpanText, getElementsChainString, getSafeText, isAngularStyleAttr, isDocumentFragment, isElementNode, isSensitiveElement, isTag, isTextNode, makeSafeText, shouldCaptureDomEvent, shouldCaptureElement, shouldCaptureValue, splitClassString, } from './autocapture-utils';
import RageClick from './extensions/rageclick';
import { AUTOCAPTURE_DISABLED_SERVER_SIDE } from './constants';
import { _isBoolean, _isFunction, _isNull, _isObject, _isUndefined } from './utils/type-utils';
import { logger } from './utils/logger';
import { document, window } from './utils/globals';
var COPY_AUTOCAPTURE_EVENT = '$copy_autocapture';
function limitText(length, text) {
    if (text.length > length) {
        return text.slice(0, length) + '...';
    }
    return text;
}
var autocapture = {
    _initializedTokens: [],
    _isDisabledServerSide: null,
    _isAutocaptureEnabled: false,
    _setIsAutocaptureEnabled: function (instance) {
        var _a;
        var disabled_server_side = _isNull(this._isDisabledServerSide)
            ? !!((_a = instance.persistence) === null || _a === void 0 ? void 0 : _a.props[AUTOCAPTURE_DISABLED_SERVER_SIDE])
            : this._isDisabledServerSide;
        var enabled_client_side = !!instance.config.autocapture;
        this._isAutocaptureEnabled = enabled_client_side && !disabled_server_side;
    },
    _previousElementSibling: function (el) {
        if (el.previousElementSibling) {
            return el.previousElementSibling;
        }
        else {
            var _el = el;
            do {
                _el = _el.previousSibling; // resolves to ChildNode->Node, which is Element's parent class
            } while (_el && !isElementNode(_el));
            return _el;
        }
    },
    _getAugmentPropertiesFromElement: function (elem) {
        var shouldCaptureEl = shouldCaptureElement(elem);
        if (!shouldCaptureEl) {
            return {};
        }
        var props = {};
        _each(elem.attributes, function (attr) {
            if (attr.name.indexOf('data-ph-capture-attribute') === 0) {
                var propertyKey = attr.name.replace('data-ph-capture-attribute-', '');
                var propertyValue = attr.value;
                if (propertyKey && propertyValue && shouldCaptureValue(propertyValue)) {
                    props[propertyKey] = propertyValue;
                }
            }
        });
        return props;
    },
    _getPropertiesFromElement: function (elem, maskInputs, maskText) {
        var _a;
        var tag_name = elem.tagName.toLowerCase();
        var props = {
            tag_name: tag_name,
        };
        if (autocaptureCompatibleElements.indexOf(tag_name) > -1 && !maskText) {
            if (tag_name.toLowerCase() === 'a' || tag_name.toLowerCase() === 'button') {
                props['$el_text'] = limitText(1024, getDirectAndNestedSpanText(elem));
            }
            else {
                props['$el_text'] = limitText(1024, getSafeText(elem));
            }
        }
        var classes = getClassNames(elem);
        if (classes.length > 0)
            props['classes'] = classes.filter(function (c) {
                return c !== '';
            });
        // capture the deny list here because this not-a-class class makes it tricky to use this.config in the function below
        var elementAttributeIgnorelist = (_a = this.config) === null || _a === void 0 ? void 0 : _a.element_attribute_ignorelist;
        _each(elem.attributes, function (attr) {
            // Only capture attributes we know are safe
            if (isSensitiveElement(elem) && ['name', 'id', 'class'].indexOf(attr.name) === -1)
                return;
            if (elementAttributeIgnorelist === null || elementAttributeIgnorelist === void 0 ? void 0 : elementAttributeIgnorelist.includes(attr.name))
                return;
            if (!maskInputs && shouldCaptureValue(attr.value) && !isAngularStyleAttr(attr.name)) {
                var value = attr.value;
                if (attr.name === 'class') {
                    // html attributes can _technically_ contain linebreaks,
                    // but we're very intolerant of them in the class string,
                    // so we strip them.
                    value = splitClassString(value).join(' ');
                }
                props['attr__' + attr.name] = limitText(1024, value);
            }
        });
        var nthChild = 1;
        var nthOfType = 1;
        var currentElem = elem;
        while ((currentElem = this._previousElementSibling(currentElem))) {
            // eslint-disable-line no-cond-assign
            nthChild++;
            if (currentElem.tagName === elem.tagName) {
                nthOfType++;
            }
        }
        props['nth_child'] = nthChild;
        props['nth_of_type'] = nthOfType;
        return props;
    },
    _getDefaultProperties: function (eventType) {
        return {
            $event_type: eventType,
            $ce_version: 1,
        };
    },
    _extractCustomPropertyValue: function (customProperty) {
        var propValues = [];
        _each(document === null || document === void 0 ? void 0 : document.querySelectorAll(customProperty['css_selector']), function (matchedElem) {
            var value;
            if (['input', 'select'].indexOf(matchedElem.tagName.toLowerCase()) > -1) {
                value = matchedElem['value'];
            }
            else if (matchedElem['textContent']) {
                value = matchedElem['textContent'];
            }
            if (shouldCaptureValue(value)) {
                propValues.push(value);
            }
        });
        return propValues.join(', ');
    },
    // TODO: delete custom_properties after changeless typescript refactor
    _getCustomProperties: function (targetElementList) {
        var _this = this;
        var props = {}; // will be deleted
        _each(this._customProperties, function (customProperty) {
            _each(customProperty['event_selectors'], function (eventSelector) {
                var eventElements = document === null || document === void 0 ? void 0 : document.querySelectorAll(eventSelector);
                _each(eventElements, function (eventElement) {
                    if (_includes(targetElementList, eventElement) && shouldCaptureElement(eventElement)) {
                        props[customProperty['name']] = _this._extractCustomPropertyValue(customProperty);
                    }
                });
            });
        });
        return props;
    },
    _getEventTarget: function (e) {
        var _a;
        // https://developer.mozilla.org/en-US/docs/Web/API/Event/target#Compatibility_notes
        if (_isUndefined(e.target)) {
            return e.srcElement || null;
        }
        else {
            if ((_a = e.target) === null || _a === void 0 ? void 0 : _a.shadowRoot) {
                return e.composedPath()[0] || null;
            }
            return e.target || null;
        }
    },
    _captureEvent: function (e, instance, eventName, extraProps) {
        var _this = this;
        var _a, _b, _c, _d;
        if (eventName === void 0) { eventName = '$autocapture'; }
        /*** Don't mess with this code without running IE8 tests on it ***/
        var target = this._getEventTarget(e);
        if (isTextNode(target)) {
            // defeat Safari bug (see: http://www.quirksmode.org/js/events_properties.html)
            target = (target.parentNode || null);
        }
        if (eventName === '$autocapture' && e.type === 'click' && e instanceof MouseEvent) {
            if ((_a = this.rageclicks) === null || _a === void 0 ? void 0 : _a.isRageClick(e.clientX, e.clientY, new Date().getTime())) {
                this._captureEvent(e, instance, '$rageclick');
            }
        }
        var isCopyAutocapture = eventName === COPY_AUTOCAPTURE_EVENT;
        if (target &&
            shouldCaptureDomEvent(target, e, this.config, 
            // mostly this method cares about the target element, but in the case of copy events,
            // we want some of the work this check does without insisting on the target element's type
            isCopyAutocapture, 
            // we also don't want to restrict copy checks to clicks,
            // so we pass that knowledge in here, rather than add the logic inside the check
            isCopyAutocapture ? ['copy', 'cut'] : undefined)) {
            var targetElementList = [target];
            var curEl = target;
            while (curEl.parentNode && !isTag(curEl, 'body')) {
                if (isDocumentFragment(curEl.parentNode)) {
                    targetElementList.push(curEl.parentNode.host);
                    curEl = curEl.parentNode.host;
                    continue;
                }
                targetElementList.push(curEl.parentNode);
                curEl = curEl.parentNode;
            }
            var elementsJson_1 = [];
            var autocaptureAugmentProperties_1 = {};
            var href_1, explicitNoCapture_1 = false;
            _each(targetElementList, function (el) {
                var shouldCaptureEl = shouldCaptureElement(el);
                // if the element or a parent element is an anchor tag
                // include the href as a property
                if (el.tagName.toLowerCase() === 'a') {
                    href_1 = el.getAttribute('href');
                    href_1 = shouldCaptureEl && shouldCaptureValue(href_1) && href_1;
                }
                // allow users to programmatically prevent capturing of elements by adding class 'ph-no-capture'
                var classes = getClassNames(el);
                if (_includes(classes, 'ph-no-capture')) {
                    explicitNoCapture_1 = true;
                }
                elementsJson_1.push(_this._getPropertiesFromElement(el, instance.config.mask_all_element_attributes, instance.config.mask_all_text));
                var augmentProperties = _this._getAugmentPropertiesFromElement(el);
                _extend(autocaptureAugmentProperties_1, augmentProperties);
            });
            if (!instance.config.mask_all_text) {
                // if the element is a button or anchor tag get the span text from any
                // children and include it as/with the text property on the parent element
                if (target.tagName.toLowerCase() === 'a' || target.tagName.toLowerCase() === 'button') {
                    elementsJson_1[0]['$el_text'] = getDirectAndNestedSpanText(target);
                }
                else {
                    elementsJson_1[0]['$el_text'] = getSafeText(target);
                }
            }
            if (href_1) {
                elementsJson_1[0]['attr__href'] = href_1;
            }
            if (explicitNoCapture_1) {
                return false;
            }
            var props = _extend(this._getDefaultProperties(e.type), instance.elementsChainAsString
                ? {
                    $elements_chain: getElementsChainString(elementsJson_1),
                }
                : {
                    $elements: elementsJson_1,
                }, ((_b = elementsJson_1[0]) === null || _b === void 0 ? void 0 : _b['$el_text']) ? { $el_text: (_c = elementsJson_1[0]) === null || _c === void 0 ? void 0 : _c['$el_text'] } : {}, this._getCustomProperties(targetElementList), autocaptureAugmentProperties_1, extraProps || {});
            if (eventName === COPY_AUTOCAPTURE_EVENT) {
                // you can't read the data from the clipboard event,
                // but you can guess that you can read it from the window's current selection
                var selectedContent = makeSafeText((_d = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _d === void 0 ? void 0 : _d.toString());
                var clipType = e.type || 'clipboard';
                if (!selectedContent) {
                    return false;
                }
                props['$selected_content'] = selectedContent;
                props['$copy_type'] = clipType;
            }
            instance.capture(eventName, props);
            return true;
        }
    },
    // only reason is to stub for unit tests
    // since you can't override window.location props
    _navigate: function (href) {
        if (!window) {
            return;
        }
        window.location.href = href;
    },
    _addDomEventHandlers: function (instance) {
        var _this = this;
        if (!window || !document) {
            return;
        }
        var handler = function (e) {
            e = e || (window === null || window === void 0 ? void 0 : window.event);
            _this._captureEvent(e, instance);
        };
        var copiedTextHandler = function (e) {
            e = e || (window === null || window === void 0 ? void 0 : window.event);
            _this._captureEvent(e, instance, COPY_AUTOCAPTURE_EVENT);
        };
        _register_event(document, 'submit', handler, false, true);
        _register_event(document, 'change', handler, false, true);
        _register_event(document, 'click', handler, false, true);
        if (_isObject(instance.config.autocapture) && instance.config.autocapture.capture_copied_text) {
            _register_event(document, 'copy', copiedTextHandler, false, true);
            _register_event(document, 'cut', copiedTextHandler, false, true);
        }
    },
    _customProperties: [],
    rageclicks: null,
    config: undefined,
    init: function (instance) {
        var _a;
        if (!_isBoolean(instance.__autocapture)) {
            this.config = instance.__autocapture;
        }
        // precompile the regex
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.url_allowlist) {
            this.config.url_allowlist = this.config.url_allowlist.map(function (url) { return new RegExp(url); });
        }
        this.rageclicks = new RageClick(instance.config.rageclick);
    },
    afterDecideResponse: function (response, instance) {
        var _a;
        var token = instance.config.token;
        if (this._initializedTokens.indexOf(token) > -1) {
            logger.info('autocapture already initialized for token "' + token + '"');
            return;
        }
        if (instance.persistence) {
            instance.persistence.register((_a = {},
                _a[AUTOCAPTURE_DISABLED_SERVER_SIDE] = !!response['autocapture_opt_out'],
                _a));
        }
        // store this in-memory incase persistence is disabled
        this._isDisabledServerSide = !!response['autocapture_opt_out'];
        this._setIsAutocaptureEnabled(instance);
        this._initializedTokens.push(token);
        if (response &&
            response['config'] &&
            response['config']['enable_collect_everything'] &&
            this._isAutocaptureEnabled) {
            // TODO: delete custom_properties after changeless typescript refactor
            if (response['custom_properties']) {
                this._customProperties = response['custom_properties'];
            }
            this._addDomEventHandlers(instance);
        }
        else {
            instance['__autocapture'] = false;
        }
    },
    // this is a mechanism to ramp up CE with no server-side interaction.
    // when CE is active, every page load results in a decide request. we
    // need to gently ramp this up, so we don't overload decide. this decides
    // deterministically if CE is enabled for this project by modding the char
    // value of the project token.
    enabledForProject: function (token, numBuckets, numEnabledBuckets) {
        if (!token) {
            return true;
        }
        numBuckets = !_isUndefined(numBuckets) ? numBuckets : 10;
        numEnabledBuckets = !_isUndefined(numEnabledBuckets) ? numEnabledBuckets : 10;
        var charCodeSum = 0;
        for (var i = 0; i < token.length; i++) {
            charCodeSum += token.charCodeAt(i);
        }
        return charCodeSum % numBuckets < numEnabledBuckets;
    },
    isBrowserSupported: function () {
        return _isFunction(document === null || document === void 0 ? void 0 : document.querySelectorAll);
    },
};
_bind_instance_methods(autocapture);
_safewrap_instance_methods(autocapture);
export { autocapture };
//# sourceMappingURL=autocapture.js.map