{"version":3,"file":"request-queue.js","sourceRoot":"","sources":["../../src/request-queue.ts"],"names":[],"mappings":"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","sourcesContent":["import { RequestQueueScaffold } from './base-request-queue'\nimport { _each } from './utils'\nimport { Properties, QueuedRequestData, XHROptions } from './types'\n\nimport { _isUndefined } from './utils/type-utils'\n\nexport class RequestQueue extends RequestQueueScaffold {\n    handlePollRequest: (url: string, data: Properties, options?: XHROptions) => void\n\n    constructor(handlePollRequest: (url: string, data: Properties, options?: XHROptions) => void, pollInterval = 3000) {\n        super(pollInterval)\n        this.handlePollRequest = handlePollRequest\n    }\n\n    enqueue(url: string, data: Properties, options: XHROptions): void {\n        this._event_queue.push({ url, data, options })\n\n        if (!this.isPolling) {\n            this.isPolling = true\n            this.poll()\n        }\n    }\n\n    poll(): void {\n        clearTimeout(this._poller)\n        this._poller = setTimeout(() => {\n            if (this._event_queue.length > 0) {\n                const requests = this.formatQueue()\n                for (const key in requests) {\n                    const { url, data, options } = requests[key]\n                    _each(data, (_, dataKey) => {\n                        data[dataKey]['offset'] = Math.abs(data[dataKey]['timestamp'] - this.getTime())\n                        delete data[dataKey]['timestamp']\n                    })\n                    this.handlePollRequest(url, data, options)\n                }\n                this._event_queue.length = 0 // flush the _event_queue\n                this._empty_queue_count = 0\n            } else {\n                this._empty_queue_count++\n            }\n\n            /**\n             * _empty_queue_count will increment each time the queue is polled\n             *  and it is empty. To avoid empty polling (user went idle, stepped away from comp)\n             *  we can turn it off with the isPolling flag.\n             *\n             * Polling will be re enabled when the next time PostHogLib.capture is called with\n             *  an event that should be added to the event queue.\n             */\n            if (this._empty_queue_count > 4) {\n                this.isPolling = false\n                this._empty_queue_count = 0\n            }\n            if (this.isPolling) {\n                this.poll()\n            }\n        }, this._pollInterval) as any as number\n    }\n\n    unload(): void {\n        clearTimeout(this._poller)\n        const requests = this._event_queue.length > 0 ? this.formatQueue() : {}\n        this._event_queue.length = 0\n        const requestValues = Object.values(requests)\n\n        // Always force events to be sent before recordings, as events are more important, and recordings are bigger and thus less likely to arrive\n        const sortedRequests = [\n            ...requestValues.filter((r) => r.url.indexOf('/e') === 0),\n            ...requestValues.filter((r) => r.url.indexOf('/e') !== 0),\n        ]\n        sortedRequests.map(({ url, data, options }) => {\n            this.handlePollRequest(url, data, { ...options, transport: 'sendBeacon' })\n        })\n    }\n\n    formatQueue(): Record<string, QueuedRequestData> {\n        const requests: Record<string, QueuedRequestData> = {}\n        _each(this._event_queue, (request) => {\n            const { url, data, options } = request\n            const key = (options ? options._batchKey : null) || url\n            if (_isUndefined(requests[key])) {\n                requests[key] = { data: [], url, options }\n            }\n\n            // :TRICKY: Metrics-only code\n            if (\n                options &&\n                requests[key].options &&\n                requests[key].options._metrics &&\n                !(requests[key].options._metrics as any)['rrweb_full_snapshot']\n            ) {\n                ;(requests[key].options._metrics as any)['rrweb_full_snapshot'] =\n                    options._metrics['rrweb_full_snapshot']\n            }\n            requests[key].data.push(data)\n        })\n        return requests\n    }\n}\n"]}