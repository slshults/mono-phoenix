var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { isDOMError, isDOMException, isError, isErrorEvent, isErrorWithStack, isEvent, isPlainObject, isPrimitive, } from './type-checking';
import { defaultStackParser } from './stack-trace';
import { _isNumber, _isString, _isUndefined } from '../../utils/type-utils';
/**
 * based on the very wonderful MIT licensed Sentry SDK
 */
var ERROR_TYPES_PATTERN = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
var reactMinifiedRegexp = /Minified React error #\d+;/i;
function getPopSize(ex) {
    if (ex) {
        if (_isNumber(ex.framesToPop)) {
            return ex.framesToPop;
        }
        if (reactMinifiedRegexp.test(ex.message)) {
            return 1;
        }
    }
    return 0;
}
export function parseStackFrames(ex) {
    // Access and store the stacktrace property before doing ANYTHING
    // else to it because Opera is not very good at providing it
    // reliably in other circumstances.
    var stacktrace = ex.stacktrace || ex.stack || '';
    var popSize = getPopSize(ex);
    try {
        return defaultStackParser(stacktrace, popSize);
    }
    catch (e) {
        // no-empty
    }
    return [];
}
function errorPropertiesFromError(error) {
    var frames = parseStackFrames(error);
    return {
        $exception_type: error.name,
        $exception_message: error.message,
        $exception_stack_trace_raw: JSON.stringify(frames),
    };
}
function errorPropertiesFromString(candidate) {
    return {
        $exception_type: 'Error',
        $exception_message: candidate,
    };
}
/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
function extractExceptionKeysForMessage(exception, maxLength) {
    if (maxLength === void 0) { maxLength = 40; }
    var keys = Object.keys(exception);
    keys.sort();
    if (!keys.length) {
        return '[object has no keys]';
    }
    for (var i = keys.length; i > 0; i--) {
        var serialized = keys.slice(0, i).join(', ');
        if (serialized.length > maxLength) {
            continue;
        }
        if (i === keys.length) {
            return serialized;
        }
        return serialized.length <= maxLength ? serialized : "".concat(serialized.slice(0, maxLength), "...");
    }
    return '';
}
function errorPropertiesFromObject(candidate) {
    return {
        $exception_type: isEvent(candidate) ? candidate.constructor.name : 'Error',
        $exception_message: "Non-Error ".concat('exception', " captured with keys: ").concat(extractExceptionKeysForMessage(candidate)),
    };
}
export function errorToProperties(_a) {
    var _b = __read(_a, 5), event = _b[0], source = _b[1], lineno = _b[2], colno = _b[3], error = _b[4];
    // exception type and message are not optional but, it's useful to start off without them enforced
    var errorProperties = {};
    if (_isUndefined(error) && _isString(event)) {
        var name_1 = 'Error';
        var message = event;
        var groups = event.match(ERROR_TYPES_PATTERN);
        if (groups) {
            name_1 = groups[1];
            message = groups[2];
        }
        errorProperties = {
            $exception_type: name_1,
            $exception_message: message,
        };
    }
    var candidate = error || event;
    if (isDOMError(candidate) || isDOMException(candidate)) {
        // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
        // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
        var domException = candidate;
        if (isErrorWithStack(candidate)) {
            errorProperties = errorPropertiesFromError(candidate);
        }
        else {
            var name_2 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');
            var message = domException.message ? "".concat(name_2, ": ").concat(domException.message) : name_2;
            errorProperties = errorPropertiesFromString(message);
            errorProperties.$exception_type = isDOMError(domException) ? 'DOMError' : 'DOMException';
            errorProperties.$exception_message = errorProperties.$exception_message || message;
        }
        if ('code' in domException) {
            errorProperties['$exception_DOMException_code'] = "".concat(domException.code);
        }
    }
    else if (isErrorEvent(candidate) && candidate.error) {
        errorProperties = errorPropertiesFromError(candidate.error);
    }
    else if (isError(candidate)) {
        errorProperties = errorPropertiesFromError(candidate);
    }
    else if (isPlainObject(candidate) || isEvent(candidate)) {
        // group these by using the keys available on the object
        var objectException = candidate;
        errorProperties = errorPropertiesFromObject(objectException);
        errorProperties.$exception_is_synthetic = true;
    }
    else {
        // If none of previous checks were valid, then it must be a string
        errorProperties.$exception_type = errorProperties.$exception_type || 'Error';
        errorProperties.$exception_message = errorProperties.$exception_message || candidate;
        errorProperties.$exception_is_synthetic = true;
    }
    return __assign(__assign(__assign(__assign(__assign({}, errorProperties), { 
        // now we make sure the mandatory fields that were made optional are present
        $exception_type: errorProperties.$exception_type || 'UnknownErrorType', $exception_message: errorProperties.$exception_message || '' }), (source
        ? {
            $exception_source: source, // TODO get this from URL if not present
        }
        : {})), (lineno ? { $exception_lineno: lineno } : {})), (colno ? { $exception_colno: colno } : {}));
}
export function unhandledRejectionToProperties(_a) {
    var _b = __read(_a, 1), ev = _b[0];
    // dig the object of the rejection out of known event types
    var error = ev;
    try {
        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in ev) {
            error = ev.reason;
        }
        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        else if ('detail' in ev && 'reason' in ev.detail) {
            error = ev.detail.reason;
        }
    }
    catch (_oO) {
        // no-empty
    }
    // exception type and message are not optional but, it's useful to start off without them enforced
    var errorProperties = {};
    if (isPrimitive(error)) {
        errorProperties = {
            $exception_message: "Non-Error promise rejection captured with value: ".concat(String(error)),
        };
    }
    else {
        errorProperties = errorToProperties([error]);
    }
    errorProperties.$exception_handled = false;
    return __assign(__assign({}, errorProperties), { 
        // now we make sure the mandatory fields that were made optional are present
        $exception_type: (errorProperties.$exception_type = 'UnhandledRejection'), $exception_message: (errorProperties.$exception_message =
            errorProperties.$exception_message || ev.reason || String(error)) });
}
//# sourceMappingURL=error-conversion.js.map