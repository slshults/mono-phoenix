var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { _register_event, _try, loadScript } from '../utils';
import { _getHashParam } from '../utils/request-utils';
import { logger } from '../utils/logger';
import { window, document, assignableWindow } from '../utils/globals';
// TRICKY: Many web frameworks will modify the route on load, potentially before posthog is initialized.
// To get ahead of this we grab it as soon as the posthog-js is parsed
var STATE_FROM_WINDOW = (window === null || window === void 0 ? void 0 : window.location)
    ? _getHashParam(window.location.hash, '__posthog') || _getHashParam(location.hash, 'state')
    : null;
var Toolbar = /** @class */ (function () {
    function Toolbar(instance) {
        this.instance = instance;
    }
    Toolbar.prototype.afterDecideResponse = function (response) {
        var toolbarParams = response['toolbarParams'] ||
            response['editorParams'] ||
            (response['toolbarVersion'] ? { toolbarVersion: response['toolbarVersion'] } : {});
        if (response['isAuthenticated'] &&
            toolbarParams['toolbarVersion'] &&
            toolbarParams['toolbarVersion'].indexOf('toolbar') === 0) {
            this.loadToolbar(__assign({}, toolbarParams));
        }
    };
    /**
     * To load the toolbar, we need an access token and other state. That state comes from one of three places:
     * 1. In the URL hash params
     * 2. From session storage under the key `toolbarParams` if the toolbar was initialized on a previous page
     */
    Toolbar.prototype.maybeLoadToolbar = function (location, localStorage, history) {
        if (location === void 0) { location = undefined; }
        if (localStorage === void 0) { localStorage = undefined; }
        if (history === void 0) { history = undefined; }
        if (!window || !document) {
            return false;
        }
        location = location !== null && location !== void 0 ? location : window.location;
        history = history !== null && history !== void 0 ? history : window.history;
        try {
            // Before running the code we check if we can access localStorage, if not we opt-out
            if (!localStorage) {
                try {
                    window.localStorage.setItem('test', 'test');
                    window.localStorage.removeItem('test');
                }
                catch (error) {
                    return false;
                }
                // If localStorage was undefined, and localStorage is supported we set the default value
                localStorage = window === null || window === void 0 ? void 0 : window.localStorage;
            }
            /**
             * Info about the state
             * The state is a json object
             * 1. (Legacy) The state can be `state={}` as a urlencoded object of info. In this case
             * 2. The state should now be found in `__posthog={}` and can be base64 encoded or urlencoded.
             * 3. Base64 encoding is preferred and will gradually be rolled out everywhere
             */
            var stateHash_1 = STATE_FROM_WINDOW || _getHashParam(location.hash, '__posthog') || _getHashParam(location.hash, 'state');
            var toolbarParams = void 0;
            var state = stateHash_1
                ? _try(function () { return JSON.parse(atob(decodeURIComponent(stateHash_1))); }) ||
                    _try(function () { return JSON.parse(decodeURIComponent(stateHash_1)); })
                : null;
            var parseFromUrl = state && state['action'] === 'ph_authorize';
            if (parseFromUrl) {
                // happens if they are initializing the toolbar using an old snippet
                toolbarParams = state;
                toolbarParams.source = 'url';
                if (toolbarParams && Object.keys(toolbarParams).length > 0) {
                    if (state['desiredHash']) {
                        // hash that was in the url before the redirect
                        location.hash = state['desiredHash'];
                    }
                    else if (history) {
                        history.replaceState('', document.title, location.pathname + location.search); // completely remove hash
                    }
                    else {
                        location.hash = ''; // clear hash (but leaves # unfortunately)
                    }
                }
            }
            else {
                // get credentials from localStorage from a previous initialzation
                toolbarParams = JSON.parse(localStorage.getItem('_postHogToolbarParams') || '{}');
                toolbarParams.source = 'localstorage';
                // delete "add-action" or other intent from toolbarParams, otherwise we'll have the same intent
                // every time we open the page (e.g. you just visiting your own site an hour later)
                delete toolbarParams.userIntent;
            }
            if (toolbarParams['token'] && this.instance.config.token === toolbarParams['token']) {
                this.loadToolbar(toolbarParams);
                return true;
            }
            else {
                return false;
            }
        }
        catch (e) {
            return false;
        }
    };
    Toolbar.prototype.loadToolbar = function (params) {
        var _this = this;
        if (!window || assignableWindow['_postHogToolbarLoaded']) {
            return false;
        }
        // only load the toolbar once, even if there are multiple instances of PostHogLib
        assignableWindow['_postHogToolbarLoaded'] = true;
        // toolbar.js is served from the PostHog CDN, this has a TTL of 24 hours.
        // the toolbar asset includes a rotating "token" that is valid for 5 minutes.
        var fiveMinutesInMillis = 5 * 60 * 1000;
        // this ensures that we bust the cache periodically
        var timestampToNearestFiveMinutes = Math.floor(Date.now() / fiveMinutesInMillis) * fiveMinutesInMillis;
        var toolbarUrl = this.instance.requestRouter.endpointFor('assets', "/static/toolbar.js?t=".concat(timestampToNearestFiveMinutes));
        var disableToolbarMetrics = this.instance.requestRouter.region === 'custom' && this.instance.config.advanced_disable_toolbar_metrics;
        var toolbarParams = __assign(__assign(__assign({ token: this.instance.config.token }, params), { apiURL: this.instance.requestRouter.endpointFor('ui') }), (disableToolbarMetrics ? { instrument: false } : {}));
        var _discard = toolbarParams.source, paramsToPersist = __rest(toolbarParams, ["source"]); // eslint-disable-line
        window.localStorage.setItem('_postHogToolbarParams', JSON.stringify(paramsToPersist));
        loadScript(toolbarUrl, function (err) {
            if (err) {
                logger.error('Failed to load toolbar', err);
                return;
            }
            ;
            (assignableWindow['ph_load_toolbar'] || assignableWindow['ph_load_editor'])(toolbarParams, _this.instance);
        });
        // Turbolinks doesn't fire an onload event but does replace the entire body, including the toolbar.
        // Thus, we ensure the toolbar is only loaded inside the body, and then reloaded on turbolinks:load.
        _register_event(window, 'turbolinks:load', function () {
            assignableWindow['_postHogToolbarLoaded'] = false;
            _this.loadToolbar(toolbarParams);
        });
        return true;
    };
    /** @deprecated Use "loadToolbar" instead. */
    Toolbar.prototype._loadEditor = function (params) {
        return this.loadToolbar(params);
    };
    /** @deprecated Use "maybeLoadToolbar" instead. */
    Toolbar.prototype.maybeLoadEditor = function (location, localStorage, history) {
        if (location === void 0) { location = undefined; }
        if (localStorage === void 0) { localStorage = undefined; }
        if (history === void 0) { history = undefined; }
        return this.maybeLoadToolbar(location, localStorage, history);
    };
    return Toolbar;
}());
export { Toolbar };
//# sourceMappingURL=toolbar.js.map