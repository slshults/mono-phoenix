var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { _isObject } from '../../utils/type-utils';
export var replacementImageURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNOCAwSDE2TDAgMTZWOEw4IDBaIiBmaWxsPSIjMkQyRDJEIi8+CjxwYXRoIGQ9Ik0xNiA4VjE2SDhMMTYgOFoiIGZpbGw9IiMyRDJEMkQiLz4KPC9zdmc+Cg==';
export var FULL_SNAPSHOT_EVENT_TYPE = 2;
export var META_EVENT_TYPE = 4;
export var INCREMENTAL_SNAPSHOT_EVENT_TYPE = 3;
export var PLUGIN_EVENT_TYPE = 6;
export var MUTATION_SOURCE_TYPE = 0;
export var MAX_MESSAGE_SIZE = 5000000; // ~5mb
/*
 * Check whether a data payload is nearing 5mb. If it is, it checks the data for
 * data URIs (the likely culprit for large payloads). If it finds data URIs, it either replaces
 * it with a generic image (if it's an image) or removes it.
 * @data {object} the rr-web data object
 * @returns {object} the rr-web data object with data uris filtered out
 */
export function ensureMaxMessageSize(data) {
    var e_1, _a;
    var stringifiedData = JSON.stringify(data);
    // Note: with compression, this limit may be able to be increased
    // but we're assuming most of the size is from a data uri which
    // is unlikely to be compressed further
    if (stringifiedData.length > MAX_MESSAGE_SIZE) {
        // Regex that matches the pattern for a dataURI with the shape 'data:{mime type};{encoding},{data}'. It:
        // 1) Checks if the pattern starts with 'data:' (potentially, not at the start of the string)
        // 2) Extracts the mime type of the data uri in the first group
        // 3) Determines when the data URI ends.Depending on if it's used in the src tag or css, it can end with a ) or "
        var dataURIRegex = /data:([\w/\-.]+);(\w+),([^)"]*)/gim;
        var matches = stringifiedData.matchAll(dataURIRegex);
        try {
            for (var matches_1 = __values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
                var match = matches_1_1.value;
                if (match[1].toLocaleLowerCase().slice(0, 6) === 'image/') {
                    stringifiedData = stringifiedData.replace(match[0], replacementImageURI);
                }
                else {
                    stringifiedData = stringifiedData.replace(match[0], '');
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return)) _a.call(matches_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return { event: JSON.parse(stringifiedData), size: stringifiedData.length };
}
export var CONSOLE_LOG_PLUGIN_NAME = 'rrweb/console@1'; // The name of the rr-web plugin that emits console logs
// Console logs can be really large. This function truncates large logs
// It's a simple function that just truncates long strings.
// TODO: Ideally this function would have better handling of objects + lists,
// so they could still be rendered in a pretty way after truncation.
export function truncateLargeConsoleLogs(_event) {
    var event = _event;
    var MAX_STRING_SIZE = 2000; // Maximum number of characters allowed in a string
    var MAX_STRINGS_PER_LOG = 10; // A log can consist of multiple strings (e.g. consol.log('string1', 'string2'))
    if (event &&
        _isObject(event) &&
        event.type === PLUGIN_EVENT_TYPE &&
        _isObject(event.data) &&
        event.data.plugin === CONSOLE_LOG_PLUGIN_NAME) {
        // Note: event.data.payload.payload comes from rr-web, and is an array of strings
        if (event.data.payload.payload.length > MAX_STRINGS_PER_LOG) {
            event.data.payload.payload = event.data.payload.payload.slice(0, MAX_STRINGS_PER_LOG);
            event.data.payload.payload.push('...[truncated]');
        }
        var updatedPayload = [];
        for (var i = 0; i < event.data.payload.payload.length; i++) {
            if (event.data.payload.payload[i] && // Value can be null
                event.data.payload.payload[i].length > MAX_STRING_SIZE) {
                updatedPayload.push(event.data.payload.payload[i].slice(0, MAX_STRING_SIZE) + '...[truncated]');
            }
            else {
                updatedPayload.push(event.data.payload.payload[i]);
            }
        }
        event.data.payload.payload = updatedPayload;
        // Return original type
        return _event;
    }
    return _event;
}
var MutationRateLimiter = /** @class */ (function () {
    function MutationRateLimiter(rrweb, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        var _a, _b;
        this.rrweb = rrweb;
        this.options = options;
        this.bucketSize = 100;
        this.refillRate = 10;
        this.mutationBuckets = {};
        this.loggedTracker = {};
        this.refillBuckets = function () {
            Object.keys(_this.mutationBuckets).forEach(function (key) {
                _this.mutationBuckets[key] = _this.mutationBuckets[key] + _this.refillRate;
                if (_this.mutationBuckets[key] >= _this.bucketSize) {
                    delete _this.mutationBuckets[key];
                }
            });
        };
        this.getNodeOrRelevantParent = function (id) {
            // For some nodes we know they are part of a larger tree such as an SVG.
            // For those we want to block the entire node, not just the specific attribute
            var node = _this.rrweb.mirror.getNode(id);
            // Check if the node is an Element and then find the closest parent that is an SVG
            if ((node === null || node === void 0 ? void 0 : node.nodeName) !== 'svg' && node instanceof Element) {
                var closestSVG = node.closest('svg');
                if (closestSVG) {
                    return [_this.rrweb.mirror.getId(closestSVG), closestSVG];
                }
            }
            return [id, node];
        };
        this.numberOfChanges = function (data) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            return (((_b = (_a = data.removes) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) +
                ((_d = (_c = data.attributes) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) +
                ((_f = (_e = data.texts) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0) +
                ((_h = (_g = data.adds) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0));
        };
        this.throttleMutations = function (event) {
            if (event.type !== INCREMENTAL_SNAPSHOT_EVENT_TYPE || event.data.source !== MUTATION_SOURCE_TYPE) {
                return event;
            }
            var data = event.data;
            var initialMutationCount = _this.numberOfChanges(data);
            if (data.attributes) {
                // Most problematic mutations come from attrs where the style or minor properties are changed rapidly
                data.attributes = data.attributes.filter(function (attr) {
                    var _a, _b, _c;
                    var _d = __read(_this.getNodeOrRelevantParent(attr.id), 2), nodeId = _d[0], node = _d[1];
                    if (_this.mutationBuckets[nodeId] === 0) {
                        return false;
                    }
                    _this.mutationBuckets[nodeId] = (_a = _this.mutationBuckets[nodeId]) !== null && _a !== void 0 ? _a : _this.bucketSize;
                    _this.mutationBuckets[nodeId] = Math.max(_this.mutationBuckets[nodeId] - 1, 0);
                    if (_this.mutationBuckets[nodeId] === 0) {
                        if (!_this.loggedTracker[nodeId]) {
                            _this.loggedTracker[nodeId] = true;
                            (_c = (_b = _this.options).onBlockedNode) === null || _c === void 0 ? void 0 : _c.call(_b, nodeId, node);
                        }
                    }
                    return attr;
                });
            }
            // Check if every part of the mutation is empty in which case there is nothing to do
            var mutationCount = _this.numberOfChanges(data);
            if (mutationCount === 0 && initialMutationCount !== mutationCount) {
                // If we have modified the mutation count and the remaining count is 0, then we don't need the event.
                return;
            }
            return event;
        };
        this.refillRate = (_a = this.options.refillRate) !== null && _a !== void 0 ? _a : this.refillRate;
        this.bucketSize = (_b = this.options.bucketSize) !== null && _b !== void 0 ? _b : this.bucketSize;
        setInterval(function () {
            _this.refillBuckets();
        }, 1000);
    }
    return MutationRateLimiter;
}());
export { MutationRateLimiter };
//# sourceMappingURL=sessionrecording-utils.js.map