import { PostHog } from '../../posthog-core';
import { DecideResponse } from '../../types';
import { type eventWithTime } from '@rrweb/types';
export declare const RECORDING_IDLE_ACTIVITY_TIMEOUT_MS: number;
export declare const RECORDING_MAX_EVENT_SIZE: number;
export declare const RECORDING_BUFFER_TIMEOUT = 2000;
export declare const SESSION_RECORDING_BATCH_KEY = "recordings";
export declare class SessionRecording {
    private instance;
    private _endpoint;
    private flushBufferTimer?;
    private buffer?;
    private queuedRRWebEvents;
    private mutationRateLimiter?;
    private _captureStarted;
    private stopRrweb;
    private receivedDecide;
    private rrwebRecord;
    private isIdle;
    private _linkedFlagSeen;
    private _lastActivityTimestamp;
    private windowId;
    private sessionId;
    private _linkedFlag;
    private _sampleRate;
    private _minimumDuration;
    private _fullSnapshotTimer?;
    _forceAllowLocalhostNetworkCapture: boolean;
    get started(): boolean;
    private get sessionManager();
    private get isSampled();
    private get sessionDuration();
    private get isRecordingEnabled();
    private get isConsoleLogCaptureEnabled();
    private get canvasRecording();
    private get recordingVersion();
    private get networkPayloadCapture();
    /**
     * defaults to buffering mode until a decide response is received
     * once a decide response is received status can be disabled, active or sampled
     */
    private get status();
    constructor(instance: PostHog);
    startRecordingIfEnabled(): void;
    stopRecording(): void;
    private makeSamplingDecision;
    afterDecideResponse(response: DecideResponse): void;
    log(message: string, level?: 'log' | 'warn' | 'error'): void;
    private _startCapture;
    private _isInteractiveEvent;
    private _updateWindowAndSessionIds;
    private _tryRRWebMethod;
    private _tryAddCustomEvent;
    private _tryTakeFullSnapshot;
    private _onScriptLoaded;
    private _scheduleFullSnapshot;
    private _gatherRRWebPlugins;
    onRRwebEmit(rawEvent: eventWithTime): void;
    private _processQueuedEvents;
    private _maskUrl;
    private clearBuffer;
    private _flushBuffer;
    private _captureSnapshotBuffered;
    private _captureSnapshot;
}
